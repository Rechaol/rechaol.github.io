## 红黑树
其实红黑树这个内容我们上个学期就有接触，但是我们一直没有认真的去学习，所以今天我们要认真的学习这个数据结构。
### 定义
首先我们知道这个红黑树其实就是基于二叉搜索树的一种改进，所以它其实就是一种BST。

1.红黑树的所有的节点都是黑的或者是红的。

2.根节点都是黑色的。

3.所有的叶子节点（NIL）都是黑色的。

4.如果一个节点是红色的，它的子节点都必须是黑色的。

5.对于每个节点，所有到叶子节点的简单道路经过的黑色节点数相同。

现在我们发现了对于一个红黑树来说，我们需要多注意每个节点到叶子节点所经过的黑色节点数。所以我们现在定义一个新的标志：黑高（black-height）,定义一个节点的黑高就是它到每个叶子节点所经过的黑色节点数量。由于红黑树的定义可以保证一个节点的黑高应该与路径无关。同时我们定义一下一个树的黑高为根节点的黑高，即:bh(tree)=bh(root)

### 定理1
根据定义4可以得出，一棵有着N个节点的红黑树的高度至多是2ln(N+1)。（反证法）

## 操作
### Insert
插入操作应该是红黑树构建阶段的一个操作，在插入的过程中，我们其实就已经完成了红黑树的构建。所以插入操作是红黑树构建和使用的基础。

由于插入一个黑色的节点可能会破坏一棵树的黑高，所以比较稳妥的方式就是插入一个红色的节点。但是由于它是红色的，可能会破坏定义4的相关规定。

所以插入之后我们需要对于出现的破坏相关要求的节点进行调整。

所以现在我们可以讨论一下出现的问题的情况：

<img src="../images/rb(1).png">
第一种情况就是插入的节点是左节点，并且它的远叔叔是红节点。
这种情况可以直接将插入节点的父节点和叔叔节点改成黑色，它的爷爷节点改成红色。

第二种情况就是插入节点的父节点是红色，并且自己是红色节点（当然在插入的时候都是红色），这种情况可以直接转换成为第三种情况之后再按照第三种情况进行调整。（至于为什么之后再聊吧，现在我也不是很理解😭）

第三种情况其实就是先把最底下的红色节点的父节点变成黑色，以及把爷爷节点变成红色，这时我们发现右边的黑色节点树比之前少了一个，这是把左边的黑色节点右旋一下，让它当头节点，这样就可以恢复之前的结构了。（我突然发现这个东西好像有点不合理哎）

至于讨论为什么第二种情况要转化成第三种情况暂且不说。
```
Tree insert(Tree head,elementtype a){
    if(head==NULL){
        Tree new=(Tree)malloc(sizeof(Treenode));
        new->data=a;
        new->color=1;
        return new;
    }
    if(a<head->data){
        if(head->left){
            insert(head->left,a);
        }else{
            head->left=insert(head->left,a);
        }
    }else if(a>head->data){
        if(head->right){
            insert(head->right,a);
        }else{
            head->right=insert(head->right,a);
        }
    }
    
}
```

### Delete
在插入完成之后，我们需要学习另外一个经常性的操作——删除。现在我们需要思考一下在删除的时候会出现什么样的情况：

好，两分钟到（如果你也是yy班上的，应该知道什么意思）
<img src="../images/rb(2).png">
<img src="../images/rb(3).png">
看看上面的图，应该大致可以看出它有几种情况。

在删除只有一个节点或没有节点的节点时是相对简单的。现在我们看看有两个节点的节点在删除时的情况。
如上图所示，case1中就是将它的兄弟节点染黑，父节点染红，然后将兄弟节点转上去。

接下来就是一个具体的例子。（就是上面红黑树的删除啦，哈哈）
<img src="../images/rb(4).png">
